# -*- coding: utf-8 -*-
#
#    This file is based on objdictgen from CanFestival
#
#    Copyright (C) 2022-2024  Svein Seldal, Laerdal Medical AS
#    Copyright (C): Edouard TISSERANT, Francis DUPIN and Laurent BESSARD
#
#    This library is free software; you can redistribute it and/or
#    modify it under the terms of the GNU Lesser General Public
#    License as published by the Free Software Foundation; either
#    version 2.1 of the License, or (at your option) any later version.
#
#    This library is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#    Lesser General Public License for more details.
#
#    You should have received a copy of the GNU Lesser General Public
#    License along with this library; if not, write to the Free Software
#    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
#    USA
import re

RE_WORD = re.compile(r'([a-zA-Z_0-9]*)')
RE_TYPE = re.compile(r'([_A-Z]*)([0-9]*)')
RE_RANGE = re.compile(r'([_A-Z]*)([0-9]*)\[([\-0-9]*)-([\-0-9]*)]')
RE_STARTS_WITH_DIGIT = re.compile(r'^(\d.*)')
RE_NOTW = re.compile(r"\W")

CATEGORIES = [("SDO_SVR", 0x1200, 0x127F), ("SDO_CLT", 0x1280, 0x12FF),
              ("PDO_RCV", 0x1400, 0x15FF), ("PDO_RCV_MAP", 0x1600, 0x17FF),
              ("PDO_TRS", 0x1800, 0x19FF), ("PDO_TRS_MAP", 0x1A00, 0x1BFF)]
INDEX_CATEGORIES = ["firstIndex", "lastIndex"]

FILE_HEADER = """\n/* File generated by gen_cfile.py. Should not be modified. */\n"""


class CFileContext:
    def __init__(self):
        self.internal_types = {}
        self.default_string_size = 10


# Format a string for making a C++ variable
def FormatName(name):
    wordlist = [word for word in RE_WORD.findall(name) if word]
    return "_".join(wordlist)


# Extract the information from a given type name
def GetValidTypeInfos(context, typename, items=None):
    items = items or []
    if typename in context.internal_types:
        return context.internal_types[typename]
    result = RE_TYPE.match(typename)
    if result:
        values = result.groups()
        if values[0] == "UNSIGNED" and int(values[1]) in [i * 8 for i in range(1, 9)]:
            typeinfos = ("UNS%s" % values[1], None, "uint%s" % values[1], True)
        elif values[0] == "INTEGER" and int(values[1]) in [i * 8 for i in range(1, 9)]:
            typeinfos = ("INTEGER%s" % values[1], None, "int%s" % values[1], False)
        elif values[0] == "REAL" and int(values[1]) in (32, 64):
            typeinfos = ("%s%s" % (values[0], values[1]), None, "real%s" % values[1], False)
        elif values[0] in ["VISIBLE_STRING", "OCTET_STRING"]:
            size = context.default_string_size
            for item in items:
                if isinstance(item, str):
                    item = item.replace('\\x00', chr(0))
                size = max(size, len(item))
            if values[1]:
                size = max(size, int(values[1]))
            typeinfos = ("UNS8", size, "visible_string", False)
        elif values[0] == "DOMAIN":
            size = 0
            for item in items:
                if isinstance(item, str):
                    item = item.replace('\\x00', chr(0))
                size = max(size, len(item))
            typeinfos = ("UNS8", size, "domain", False)
        elif values[0] == "BOOLEAN":
            typeinfos = ("UNS8", None, "boolean", False)
        else:
            # FIXME: The !!! is for special UI handling
            raise ValueError("!!! '%s' isn't a valid type for CanFestival." % typename)
        if typeinfos[2] not in ["visible_string", "domain"]:
            context.internal_types[typename] = typeinfos
    else:
        # FIXME: The !!! is for special UI handling
        raise ValueError("!!! '%s' isn't a valid type for CanFestival." % typename)
    return typeinfos


def ComputeValue(type_, value):
    if type_ == "visible_string":
        return '"%s"' % value, ""
    if type_ == "domain":
        return '"%s"' % ''.join(["\\x%2.2x" % ord(char) for char in value.replace('\\x00', chr(0))]), ""
    if type_.startswith("real"):
        return "%f" % value, ""
    # value is integer; make sure to handle negative numbers correctly
    if value < 0:
        return "-0x%X" % (-value), "\t/* %s */" % str(value)
    return "0x%X" % value, "\t/* %s */" % str(value)


def GetTypeName(node, typenumber):
    typename = node.GetTypeName(typenumber)
    if typename is None:
        # FIXME: The !!! is for special UI handling
        raise ValueError("!!! Datatype with value '0x%4.4X' isn't defined in CanFestival." % typenumber)
    return typename
